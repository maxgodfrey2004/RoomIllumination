<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Room Illumination</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
          rel="stylesheet"/>
</head>
<body class="ml-2" onload="draw()">
  <h1>Room Illumination Demonstration</h1>
  <p>
    Press "Start Animation" to begin the simulation and "Stop Animation" to end
    it.
    If you take a recording using the "Start Recording" and "Stop Recording"
    buttons, a preview of the recording will appear under
    <a href="#recordingHeader">Recording</a>.
  </p>
  <h2 id="recordingHeader">Recording</h2>
  <div class="d-flex">
    <span class="mr-2">
      Recording duration (in seconds):
    </span>
    <input id="durationBox" class="mr-2" type="text" value="180" size="5">
    </input>
    <button id="startButton" class="btn btn-primary btn-sm mr-2"
            onclick="startRecording()">
      Start Recording
    </button>
    <button id="stopButton" class="btn btn-primary btn-sm mr-2"
            onclick="stopRecording()">
      Stop Recording
    </button>
    <button id="startAllButton" class="btn btn-success btn-sm"
            onclick="startAnimationAndRecording()">
      Start Animation and Recording
    </button>
  </div>
  <div>
    <p id="status">Status: Recording not started</p>
    <video id="preview" class="border border-dark" width="160" height="120"
           autoplay muted></video>
    <video id="recording" class="border border-dark" width="160" height="120"
           controls></video>
  </div>
  <br/>
  <div class="d-flex">
    <span class="mr-2">
      After the recording is complete:
    </span>
    <a class="btn btn-link btn-sm border border-dark" type="button
       id="downloadButton" class="button">
      Download
    </a>
  </div>
  <h2>Animation</h2>
  <div>
    <button id="drawButton" class="btn btn-primary btn-sm mr-2"
            onclick="startAnimation()">
      Start Animation
    </button>
    <button id="stopButton" class="btn btn-primary btn-sm mr-2"
            onclick="stopAnimation()">
      Stop Animation
    </button>
  </div>
  <br/>
  <canvas id="canvas" width="1000" height="800"
          style="border: 1px solid black;"></canvas>
  <script src="classes.js"></script>
  <script>
    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');

    const BACKGROUND_COLOR = 'black';
    const WALL_COLOR = '#A13D63';
    const MAG_COLOR = '#74D3AE';
    const ORIGIN_COLOR = MAG_COLOR;
    const PHOTON_HEAD_COLOR = 'yellow';
    const PHOTON_TAIL_COLOR = 'orange';
    
    const ORIGIN = [300, 500]; // The light source
    const MAG = [700, 500]; // The point to be magnified

    const MAG_SIDE = 20; // Side length of the `MAG` box.
    const MAG_VIEW = [700, 150]; // The centre of the magnified view
    const MAG_VIEW_SIDE = 200; // Side length of the `MAX_VIEW` box.

    // Do not change: to alter these polygons, change `MAG`.
    const MAG_SQUARE = new Square(
      MAG[0] - MAG_SIDE / 2,
      MAG[1] - MAG_SIDE / 2,
      MAG_SIDE
    );
    const MAG_BOX = [
      [MAG[0] - MAG_SIDE / 2, MAG[1] - MAG_SIDE / 2],
      [MAG[0] - MAG_SIDE / 2, MAG[1] + MAG_SIDE / 2],
      [MAG[0] + MAG_SIDE / 2, MAG[1] + MAG_SIDE / 2],
      [MAG[0] + MAG_SIDE / 2, MAG[1] - MAG_SIDE / 2],
    ]

    // Do not change: to alter this polygon, change `MAG_VIEW`.
    const MAG_VIEW_BOX = [
      [MAG_VIEW[0] - MAG_VIEW_SIDE / 2, MAG_VIEW[1] - MAG_VIEW_SIDE / 2],
      [MAG_VIEW[0] - MAG_VIEW_SIDE / 2, MAG_VIEW[1] + MAG_VIEW_SIDE / 2],
      [MAG_VIEW[0] + MAG_VIEW_SIDE / 2, MAG_VIEW[1] + MAG_VIEW_SIDE / 2],
      [MAG_VIEW[0] + MAG_VIEW_SIDE / 2, MAG_VIEW[1] - MAG_VIEW_SIDE / 2],
    ]
    
    const COORDS = [
      [100, 300],
      [300, 300],
      [400, 400],
      [500, 300],
      [600, 400],
      [700, 300],
      [900, 300],
      [800, 400],
      [900, 500],
      [900, 700],
      [800, 600],
      [700, 700],
      [500, 700],
      [600, 600],
      [500, 500],
      [500, 700],
      [400, 600],
      [300, 700],
      [200, 600],
      [100, 700],
      [100, 500],
      [200, 400],
    ];

    const RENDER_INTERVAL_TIME = 30;

    var boundaries = new Array(); // LineSegment instances representing walls.
    var photons = new Array(); // Photon instances representing light.
    var renderInterval;

    // Streaks of light in the `MAG` box.
    // Stores information in the form [Point1, Point2, Color].
    var magLines = new Array(); // Streaks of light in the `MAG` box.

    // Recording infrastructure.
    var video = document.getElementById('recording');
    var preview = document.getElementById('preview');
    var downloadButton = document.getElementById('downloadButton');
    var statusElement = document.getElementById('status');
    var durationBox = document.getElementById('durationBox');
    var recordingChunks = new Array();

    function wait(delayInMS) {
      return new Promise((resolve) => setTimeout(resolve, delayInMS));
    }

    function displayStatus(message) {
      statusElement.innerHTML = message;
    }

    function recordFor(stream, lengthInMS) {
      let recorder = new MediaRecorder(stream);
      let data = [];
      recorder.ondataavailable = (event) => data.push(event.data);
      recorder.start();
      displayStatus(`Status: ${lengthInMS}ms Recording Started`);
      let stopped = new Promise((resolve, reject) => {
        recorder.onstop = resolve;
        recorder.onerror = (event) => reject(event.name);
      });
      let recorded = wait(lengthInMS).then(() => {
        if (recorder.state === 'recording') {
          recorder.stop();
        }
      });
      return Promise.all([stopped, recorded]).then(() => data);
    }

    function startRecording() {
      var duration = parseInt(durationBox.value);
      if (isNaN(duration)) {
        alert('Non-integer value in duration box.');
        return;
      }
      duration *= 1000; // Convert to ms.
      let stream = canvas.captureStream(RENDER_INTERVAL_TIME);
      preview.srcObject = stream;
      downloadButton.href = stream;
      preview.captureStream =
        preview.captureStream || preview.mozCaptureStream;
      // Play the preview and record from it.
      new Promise((resolve) => {
        preview.onplaying = resolve;
      }).then(() => {
        return recordFor(preview.captureStream(), duration);
      }).then((recordedChunks) => {
        let recordedBlob = new Blob(recordedChunks, { type: 'video/webm' });
        recording.src = URL.createObjectURL(recordedBlob);
        downloadButton.href = recording.src;
        downloadButton.download = 'RecordedVideo.webm';
        displayStatus('Status: Recording finished');
      }).catch((error) => {
        alert(error);
      });
    }

    function stopRecording() {
      preview.srcObject.getTracks().forEach((track) => track.stop());
    }

    function loadBoundaries() {
      boundaries = new Array();
      for (var i = 0; i < COORDS.length; ++i) {
        nxtIdx = (i + 1) % COORDS.length;
        boundaries.push(new LineSegment(
          COORDS[i][0],
          COORDS[i][1],
          COORDS[nxtIdx][0],
          COORDS[nxtIdx][1]
        ));
      }
    }
    
    function createPhotons() {
      photons = new Array();
      // Testing photons:
      // photons.push(new Photon(ORIGIN[0], ORIGIN[1], 0.349, 0.3, 0.151));
      // photons.push(new Photon(ORIGIN[0], ORIGIN[1], -0.349, 0.3, 0.151));
      for (var i = 0; i <= 255; ++i) {
        photons.push(new Photon(
          ORIGIN[0],
          ORIGIN[1],
          (i / 256) * 2 * Math.PI,
          0.151,
          0.151,
          PHOTON_HEAD_COLOR,
          PHOTON_TAIL_COLOR
        ));
      }
    }

    function drawCircle(x, y, radius, color) {
      ctx.beginPath();
      ctx.fillStyle = color; 
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fill();
    }

    function drawLine(x1, y1, x2, y2, color, width = 0.5) {
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    function drawBackground() {
      ctx.beginPath();
      ctx.fillStyle = BACKGROUND_COLOR;
      ctx.rect(0, 0, canvas.width, canvas.height);
      ctx.fill();
    }

    function drawRoom() {
      for (var i = 0; i < COORDS.length; ++i) {
        var nxtIdx = (i + 1) % COORDS.length;
        drawLine(COORDS[i][0], COORDS[i][1], COORDS[nxtIdx][0],
            COORDS[nxtIdx][1], WALL_COLOR, 10);
        drawCircle(COORDS[i][0], COORDS[i][1], 5, WALL_COLOR);
      }
      ctx.beginPath();
      ctx.fillStyle = BACKGROUND_COLOR;
      ctx.moveTo(COORDS[0][0], COORDS[0][1]);
      for (var i = 0; i < COORDS.length; ++i) {
        nxtIdx = (i + 1) % COORDS.length;
        ctx.lineTo(COORDS[nxtIdx][0], COORDS[nxtIdx][1]);
      }
      ctx.closePath();
      ctx.fill();
    }

    function drawPointsOfInterest() {
      drawCircle(ORIGIN[0], ORIGIN[1], 2, ORIGIN_COLOR);
      drawCircle(MAG[0], MAG[1], 2, MAG_COLOR);
      drawCircle(MAG[0], MAG[1], 0.7, BACKGROUND_COLOR);
    }

    function drawPhotons() {
      for (var i = 0; i < photons.length; ++i) {
        const len = photons[i].contactPoints.length;
        for (var j = 0; j < len - 1; ++j) {
          drawLine(
            photons[i].contactPoints[j][0],
            photons[i].contactPoints[j][1],
            photons[i].contactPoints[j + 1][0],
            photons[i].contactPoints[j + 1][1],
            photons[i].tailColor
          );
        }
        drawLine(
          photons[i].contactPoints[len - 1][0],
          photons[i].contactPoints[len - 1][1],
          photons[i].x,
          photons[i].y,
          photons[i].tailColor
        );
      }
      for (var i = 0; i < photons.length; ++i) {
        if (photons[i].active) {
          drawCircle(photons[i].x, photons[i].y, 1.3, photons[i].headColor);
        }
      }
    }

    function drawMag() {
      // Draw the circle.
      drawCircle(MAG_VIEW[0], MAG_VIEW[1], 3, MAG_COLOR);
      drawCircle(MAG_VIEW[0], MAG_VIEW[1], 1.5, BACKGROUND_COLOR);
      // Draw lines from past photons.
      for (var i = 0; i < magLines.length; ++i) {
        drawLine(
          magLines[i][0][0],
          magLines[i][0][1],
          magLines[i][1][0],
          magLines[i][1][1],
          magLines[i][2],
          1
        );
      }
      // Draw the photons.
      for (var i = 0; i < photons.length; ++i) {
        if (MAG_SQUARE.contains(photons[i].x, photons[i].y)) {
          var dx = photons[i].x - MAG[0];
          var dy = photons[i].y - MAG[1];
          var viewerX = MAG_VIEW[0] + (MAG_VIEW_SIDE / MAG_SIDE) * dx;
          var viewerY = MAG_VIEW[1] + (MAG_VIEW_SIDE / MAG_SIDE) * dy;
          drawCircle(viewerX, viewerY, 3, photons[i].headColor);
          drawLine(photons[i].magEntry[0], photons[i].magEntry[1], viewerX,
              viewerY, photons[i].tailColor, 1);
        }
      }
      // Draw the box around the point in the room.
      for (var i = 0; i < MAG_BOX.length; ++i) {
        var nxtIdx = (i + 1) % MAG_BOX.length;
        drawLine(MAG_BOX[i][0], MAG_BOX[i][1], MAG_BOX[nxtIdx][0],
            MAG_BOX[nxtIdx][1], MAG_COLOR, 1);
        drawCircle(MAG_BOX[i][0], MAG_BOX[i][1], 0.5, MAG_COLOR);
      }
      // Draw the viewer bounds.
      for (var i = 0; i < MAG_VIEW_BOX.length; ++i) {
        var nxtIdx = (i + 1) % MAG_VIEW_BOX.length;
        drawLine(MAG_VIEW_BOX[i][0], MAG_VIEW_BOX[i][1],
            MAG_VIEW_BOX[nxtIdx][0], MAG_VIEW_BOX[nxtIdx][1], MAG_COLOR, 2);
        drawCircle(MAG_VIEW_BOX[i][0], MAG_VIEW_BOX[i][1], 1, MAG_COLOR);
      }
    }

    function draw() {
      drawBackground();
      drawRoom();
      drawPhotons();
      drawPointsOfInterest();
      drawMag();
    }

    function updatePositions() {
      // Delete photons that hit corners.
      for (var i = photons.length - 1; i >= 0; --i) {
        for (var point = 0; point < COORDS.length; ++point) {
          if (photons[i].checkPointCollision(
                COORDS[point][0], COORDS[point][1])) {
            photons[i].deactivate();
            break;
          }
        }
      }
      // Bounce photons off edges.
      for (var i = 0; i < photons.length; ++i) {
        for (var edge = 0; edge < boundaries.length; ++edge) {
          if (edge !== photons[i].lastBounce &&
              photons[i].checkLineCollision(boundaries[edge])) {
            photons[i].lastBounce = edge;
            photons[i].bounceOffSegment(boundaries[edge]);
            hasBounced = true;
            break;
          }
        }
      }
      // Move the photons.
      for (var i = 0; i < photons.length; ++i) {
        photons[i].updatePosition();
      }
    }

    function updateMag() {
      for (var i = 0; i < photons.length; ++i) {
        if (MAG_SQUARE.contains(photons[i].x, photons[i].y)) {
          var dx = photons[i].x - MAG[0];
          var dy = photons[i].y - MAG[1];
          var viewerX = MAG_VIEW[0] + (MAG_VIEW_SIDE / MAG_SIDE) * dx;
          var viewerY = MAG_VIEW[1] + (MAG_VIEW_SIDE / MAG_SIDE) * dy;
          if (photons[i].magEntry === null) {
            // Just entered the square.
            photons[i].magEntry = [viewerX, viewerY];
          }
          photons[i].lastMagPoint = [viewerX, viewerY];
        } else if (!MAG_SQUARE.contains(photons[i].x, photons[i].y) &&
            photons[i].magEntry !== null) {
          // Just left the square.
          magLines.push([
            photons[i].magEntry,
            photons[i].lastMagPoint,
            photons[i].tailColor,
          ]);
          photons[i].magEntry = null;
          photons[i].lastMagPoint = null;
        }
      }
    }

    function updateScreen() {
      for (var i = 0; i < 10; ++i) {
        updatePositions();
        updateMag();
      }
      draw();
    }

    function startAnimation() {
      clearInterval(renderInterval);
      magLines = new Array();
      loadBoundaries();
      createPhotons();
      renderInterval = setInterval(updateScreen, RENDER_INTERVAL_TIME);
    }

    function startAnimationAndRecording() {
      startAnimation();
      startRecording();
    }

    function stopAnimation() {
      clearInterval(renderInterval);
    }
  </script>
</body>
</html>